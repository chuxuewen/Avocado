/* ***** BEGIN LICENSE BLOCK *****
 * Distributed under the BSD license:
 *
 * Copyright (c) 2015, Louis.chu
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of Louis.chu nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL Louis.chu BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 * 
 * ***** END LICENSE BLOCK ***** */

var util = require('./util');
var export_paths = require('./export_paths');
var fs = require('./fs');
var path = require('./path');
var keys = require('./keys');
var sys = require('os');
var child_process = require('child_process');
var AvocadoBuild = require('./build').AvocadoBuild;
var get_local_network_host = require('./remote_console').get_local_network_host;

var native_source = [
	'.c',
	'.cc',
	'.cpp',
	'.cxx',
	'.m',
	'.mm',
	'.s', 
	'.swift',
];

function gen_gypi(self, lib_keys, is_app) {
	var os = self.m_os;
	var name = self.m_cur_lib_name;
	var type = 'none';
	var includes = [ ];
	var include_dirs = [ ];
	var dependencies = [ '<@(avocado)' ];
	var sources = [ 'public' ];
	var sources_test = [ ];
	var mac_bundle = 0;
	var resources = self.m_resources.concat([]);
	var install_resources = [ ];
	var xcode_settings = { };
	var native = false;
	var relative = path.relative(self.m_output, self.m_cur_lib_source_path);
	
	// add depe

	for ( var pathname in lib_keys.depe ) {
		if ( ! /^https?:\/\//i.test(pathname) ) { 
			self.m_includes[self.m_output + '/' + path.basename(pathname) + '.gypi'] = 1;
			dependencies.push( path.basename(pathname) );
		}
	}

	for ( var pathname in lib_keys.depe_native ) {
		self.m_includes[ util.format(self.m_cur_lib_source_path, pathname, '/native.gypi') ] = 1;
		var target = lib_keys.depe_native[pathname];
		if ( target ) {
			if ( util.is_array(target) ) {
				dependencies = dependencies.concat(target);
			} else {
				dependencies.push( target );
			}
		} else {
			dependencies.push( path.basename(pathname) );
		}
	}

	// add native and source

	if ( fs.existsSync(self.m_cur_lib_source_path + '/native') ) {
		fs.ls_sync(self.m_cur_lib_source_path + '/native').forEach(function(stat) {
			if ( stat.name[0] != '.' ) {
				if ( stat.isFile() ) {
					var extname = path.extname(stat.name).toLowerCase();
					if (native_source.indexOf(extname) == -1) { // resources
						resources.push( relative + '/native/' + stat.name );
					} else { // native source
						native = 1;
					}
				}
				sources.push( relative + '/native/' + stat.name );
			}
		});
	}

	fs.ls_sync(self.m_cur_lib_source_path).forEach(function(stat) {
		if ( stat.name != 'native' && stat.name[0] != '.' ) {
			if ( stat.isFile() ) {
				var extname = path.extname(stat.name).toLowerCase();
				if (native_source.indexOf(extname) == -1) {
					sources.push( relative + '/' + stat.name );
				}
			} else {
				sources.push( relative + '/' + stat.name );
			}
		}
	});

	if ( ! lib_keys.skip_install ) { // no skip install lib
		install_resources.push('install/' + name);
	}

	if ( native ) {
		include_dirs = [ relative + '/native' ];
	}

	if ( is_app ) { // copy platfoem file

		type = 'executable';
		mac_bundle = 1;
		xcode_settings = {
			'INFOPLIST_FILE': '<(XCODE_INFOPLIST_FILE)',
			'OTHER_LDFLAGS': '-all_load',
			'ASSETCATALOG_COMPILER_APPICON_NAME': 'AppIcon',
			'ASSETCATALOG_COMPILER_LAUNCHIMAGE_NAME': 'LaunchImage',
		};

		// add app start native source file

		var out = self.m_proj_out;
		var template = __dirname + '/export/'+ os +'/';
		var start_argv = '';
		var start_argv_test = '"http://' + get_local_network_host()[0] + ':1026/' + name + ' --debug --no_cache"';

		if ( lib_keys.skip_install ) {
			if ( !lib_keys.origin || !/^https?:\/\//.test(String(lib_keys.origin)) ) {
				console.error( 'Application', name, 'no valid boot parameters.' );
				// start_argv = JSON.stringify(String(lib_keys.origin || ''));
				start_argv = 'Path::resources("' + name + '")';
			} else {
				start_argv = JSON.stringify(lib_keys.origin);
			}
		} else {
			start_argv = 'Path::resources("' + name + '")';
		}

		if ( os == 'ios' ) {
			var plist = out + '/' + name + '.plist';
			var plist_test = out + '/' + name + '-test.plist';
			var storyboard = out + '/' + name + '.storyboard';
			var xcassets = out + '/' + name + '.xcassets';
			var main = out + '/' + name + '.mm';
			var main_test = out + '/' + name + '-test.mm';
			
			// .plist
			if ( !fs.existsSync(plist) ) { 
				var plist_value = fs.readFileSync(template + 'main.plist').toString('utf8');
				plist_value = plist_value.replace('[Storyboard]', name);
				fs.writeFileSync( plist, plist_value );
			}
			// .plist test
			if ( !fs.existsSync(plist_test) ) { 
				var plist_value = fs.readFileSync(template + 'main.plist').toString('utf8');
				plist_value = plist_value.replace('[Storyboard]', name);
				fs.writeFileSync( plist_test, plist_value );
			}
			// .storyboard
			if ( !fs.existsSync(storyboard) ) {
				fs.cp_sync( template + 'main.storyboard', storyboard );
			}			
			// .xcassets
			if ( !fs.existsSync(xcassets) ) {
				fs.cp_sync( template + 'Images.xcassets', xcassets );
			}
			resources.push('../project/<(OS)/' + name + '.xcassets');

			if ( !fs.existsSync(main) ) { // main.mm
				var main_value = fs.readFileSync(template + 'main.mm').toString('utf8');
				main_value = main_value.replace(/start\(""\)/, 'start(' + start_argv + ')');
				fs.writeFileSync( main, main_value );
			}
			if ( !fs.existsSync(main_test) ) {
				var main_value = fs.readFileSync(template + 'main.mm').toString('utf8');
				main_value = main_value.replace(/START_ARGV ""/, 'START_ARGV ' + start_argv_test);
				main_value = main_value.replace(/start\(""\)/, 'start(' + start_argv_test + ')');
				fs.writeFileSync( main_test, main_value );
			}

			sources.push('../project/<(OS)/' + name + '.plist');
			sources.push('../project/<(OS)/' + name + '-test.plist');
			sources.push('../project/<(OS)/' + name + '.storyboard');
			sources.push('../project/<(OS)/' + name + '.mm');
			sources_test = sources.slice(0, sources.length - 1);
			sources_test.push('../project/<(OS)/' + name + '-test.mm');

		} else if ( os == 'mac' ) {
			throw new Error('Coming soon')
		} else if ( os == 'android' ) {
			throw new Error('Coming soon')
		}

	} else {
		type = native ? 'static_library' : 'none';
	}

	var gypi = 
	{
		'includes': includes,
		'targets':[
			{
				'target_name': name,
				'type': type,
				'include_dirs': include_dirs,
		    'dependencies': dependencies,
		    'direct_dependent_settings': {
		      'include_dirs': include_dirs,
		      'mac_bundle_resources': resources,
		    },
				'sources': sources,
				'mac_bundle': mac_bundle,
				'mac_bundle_resources': is_app ? (resources.concat(install_resources)) : [ ],
				'xcode_settings': xcode_settings,
			},
		]
	};

	if ( is_app ) {
		gypi.targets[0].variables = {
			'XCODE_INFOPLIST_FILE': '$(SRCROOT)/project/<(OS)/' + name + '.plist',
		};
		gypi.targets[0].product_name = name + '-2';
		gypi.targets[1] = 
		{
			'variables': { 
				'XCODE_INFOPLIST_FILE': '$(SRCROOT)/project/<(OS)/' + name + '-test.plist', 
			},
			'target_name': name + '-test',
			'type': type,
			'include_dirs': include_dirs,
	    'dependencies': dependencies,
			'sources': sources_test,
			'mac_bundle': mac_bundle,
			'mac_bundle_resources': resources,
			'xcode_settings': xcode_settings,
		};
	} else { // lib
		gypi.targets[1] = 
		{
		 	'target_name': name + '_install_resources',
		 	'type': 'none',
		 	'direct_dependent_settings': {
	       'mac_bundle_resources': install_resources,
	    },
		};
	}

	return gypi;
}

function set_app_dependencies(self, app_gypi, dependencies, mark) {
	dependencies.forEach(function(name) {
		if ( name && !mark[name] ) {
			mark[name] = true;
			app_gypi.targets[0].dependencies.push(name);
			app_gypi.targets[1].dependencies.push(name);
			var out = self.m_output_gypi[name];
			if ( out ) {
				var depe_gypi = out.gypi;
				if (depe_gypi.targets[0].type != 'executable') {
					app_gypi.targets[0].dependencies.push(name + '_install_resources');
				}
				set_app_dependencies(self, app_gypi, depe_gypi.targets[0].dependencies, mark);
			}
		}
	});
}

function export_lib(self, pathname, is_app, ignore_depe, libs_depe) {
	var source_path = util.format(pathname);
  var name = path.basename(source_path);
  
  // ignore network pkg 
  if ( /^https?:\/\//i.test(source_path) ) { 
    return;
  }
  if ( self.m_output_gypi[name] ) { // Already complete
    return;
  }
  
  var lib_keys = keys.parse_file(source_path + '/lib.keys');
  
  util.assert(lib_keys.name && lib_keys.name == name, 
              'Lib name must be consistent with the folder name, ' + 
              name + ' != ' + lib_keys.name);

  self.m_cur_lib_name = name;
  self.m_cur_lib_source_path = source_path;
  self.m_output_gypi[name] = { 
  	gypi: gen_gypi(self, lib_keys, is_app), 
  	is_app: is_app,
  };

  var gypi = self.m_output_gypi[name].gypi;
  
  if ( !ignore_depe ) {
	  for (var pathname in lib_keys.depe) {
	  	pathname = util.is_absolute(pathname) ? pathname : source_path + '/' + pathname;
	  	export_lib(self, pathname, false, false, libs_depe);
	  }
	}

 	if ( is_app ) { // set dependencies
  	var gypi = self.m_output_gypi[name].gypi;
  	var dependencies = gypi.targets[0].dependencies;
  	gypi.targets[0].dependencies = [ ];
  	gypi.targets[1].dependencies = [ ];
  	set_app_dependencies(self, gypi, dependencies, { });

  	var new_dependencies = gypi.targets[0].dependencies;

  	// add libs depe
  	for ( var i = 0; i < libs_depe.length; i++ ) {
  		var name = libs_depe[i];
  		if ( new_dependencies.indexOf(name) == -1 ) {
  			gypi.targets[0].dependencies.push(name, name + '_install_resources');
				gypi.targets[1].dependencies.push(name, name + '_install_resources');
  		}
  	}
  }
}

function get_shell_cmd(self) {

	var gyp_exec = process.env.win ? __dirname + '/gyp/gyp.bat' : __dirname + '/gyp/gyp';
	var os = self.m_os;
	var proj_type = 'make';

	if ( os == 'ios' || os == 'mac' ) {
		proj_type = 'xcode';
	} else if ( os.indexOf('win') != -1 ) {
		proj_type = 'msvs';
	}

	var includes = ' -Iout/var.gypi';

	fs.writeFileSync(self.m_source + '/out/var.gypi', 
									'{"variables":{"OS":"{0}", "project":"{1}"}}'.format(os, proj_type) );

	export_paths.includes_gypi.map(function(str) { 
		includes += ' -I' + path.relative(self.m_source, str);
	});
	
	var shell = '\
	GYP_GENERATORS=' + proj_type + ' ' + gyp_exec + ' \
	-f ' + proj_type + '  \
	--generator-output="' + self.m_proj_out + '" \
	-Goutput_dir="' + self.m_output + '" \
	' + self.m_project_name + '.gyp \
	-Dos='+ os +' \
	-DOS=' + os + includes + ' \
	--depth=. \
	';

	return shell;
}

function export_result(self) {

	// write gyp

	for ( var i in self.m_output_gypi ) {
		var out = self.m_output_gypi[i];
		var gypi_path = self.m_output + '/' + i + '.gypi';
		self.m_includes[gypi_path] = 1;
		fs.writeFileSync( gypi_path, JSON.stringify(out.gypi, null, 2));
	}

	var includes = [ ];
	for ( var pathname in self.m_includes ) {
		includes.push(path.relative(self.m_source, pathname));
	}

	var avocado_path = export_paths.avocado_gyp_project(self.m_source);

	var gyp = 
	{
		'variables': {
			'avocado': [ avocado_path ? + ':avocado' : 'avocado' ],
		},
		'includes': includes,
	};

	fs.writeFileSync( self.m_source + '/' + self.m_project_name +'.gyp', JSON.stringify(gyp, null, 2) );

	// gen target project 

	var cmd = get_shell_cmd(self);

	// console.log(cmd);

	child_process.execSync(cmd);
}

/**
 * @class AvocadoExport
 */
var AvocadoExport = util.class('AvocadoExport', {
	m_source: '',
	m_output: '',
	m_proj_out: '',
	m_os: '',
	m_output_gypi: null,
	m_cur_lib_name 	: '',
	m_cur_lib_source_path: '',
	m_includes: null,
	m_project_name: 'app',
	m_avocado_libs: null,
	m_resources: null,

	constructor: function (source, os) {
		var self = this;
		this.m_source = util.format(source);
		this.m_output = util.format(source, 'out');
		this.m_os = os;
		this.m_proj_out = util.format(source, 'project', os);
		this.m_output_gypi = { };
		this.m_includes = { };
		this.m_resources = export_paths.avocado_resources.map(function(p) { 
			var pathname = self.m_output + '/avocado/' + path.basename(p);
			fs.cp_sync(p, pathname);
			return path.relative(self.m_output, pathname);
		});

		var app_keys = this.m_source + '/app.keys';

		util.assert(fs.existsSync(app_keys), 'Export source does not exist ,{0}', app_keys);
		
		fs.mkdir_p_sync(this.m_output);
		fs.mkdir_p_sync(this.m_output + '/public');
		fs.mkdir_p_sync(this.m_proj_out);
	},

	start: function() {
		var self = this;
		var os = this.m_os;

		util.assert(
			os == 'android' || 
			os == 'ios' || 
			os == 'mac', 'do not support {0} os', os);

		// export libs

		var depe_libs = [];
    var libs_path = self.m_source + '/libs';

    if ( fs.existsSync(libs_path) && fs.statSync(libs_path).isDirectory() ) {
      fs.ls_sync(libs_path).forEach(function(stat) {
        var source = libs_path + '/' + stat.name;
        if ( stat.isDirectory() && fs.existsSync(source + '/lib.keys') ) {
          export_lib(self, source, false, true, []);
          depe_libs.push(stat.name);
        }
      });
    }

    // export apps

		var app_keys = keys.parse_file(this.m_source + '/app.keys');
		
		for ( var name in app_keys ) {
      if (name[0] == '@') { // 忽略 @
        if ( name == '@project' ) {
        	this.m_project_name = app_keys[name];
        }
      } else {
    		if ( ! fs.existsSync(this.m_output + '/install/' + name) ) {
					new AvocadoBuild(this.m_source, this.m_output).start();
    		}
      	util.assert(fs.existsSync(this.m_output + '/install/' + name), 'Installation directory not found');
      	export_lib(this, this.m_source + '/' + name, true, false, depe_libs);
      }
    }

    export_result(this);
	}

});

exports.AvocadoExport = AvocadoExport;
